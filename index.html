<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥ ÏïîÍ∏∞ Ïï±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            font-size: 14px;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: visible;
            position: relative;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px 15px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9rem;
        }

        .reset-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .reset-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .reset-button:active {
            transform: scale(0.95);
        }

        .theme-button {
            position: absolute;
            top: 15px;
            right: 55px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .theme-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .theme-button:active {
            transform: scale(0.95);
        }

        body.mono-mode .container {
          filter: grayscale(1) contrast(1.05);
        }

        .content {
            padding: 15px;
        }

        .input-section {
            background: #f8f9ff;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px solid #e3e8ff;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }

        .input-field {
            width: 100%;
        }

        .input-field label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: #4c51bf;
            font-size: 0.9rem;
        }

        .input-field input {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .input-field input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .button-group {
            display: flex;
            gap: 6px;
            justify-content: space-between;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
            flex: 1;
            white-space: nowrap;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn-review {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3) !important;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
        }

        .btn-export {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }

        .btn-edit {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        }

        .btn-small {
            padding: 6px 10px;
            font-size: 12px;
            min-width: auto;
            flex: 0 1 auto;
        }

        .btn-kbbi { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }
        .btn-naver { background: linear-gradient(135deg, #03c75a 0%, #00e676 100%); }
        .btn-daum  { background: linear-gradient(135deg, #007bff 0%, #00bfff 100%); }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 15px 10px;
            border-radius: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 3px;
        }

        .stat-label {
            color: #4a5568;
            font-weight: 600;
            font-size: 0.8rem;
        }

        .word-lists {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .word-list {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        .word-list-header {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #2d3748;
            padding: 15px;
            font-weight: 700;
            font-size: 1rem;
            text-align: center;
        }

        .memorized-header {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .word-list-content {
            padding: 10px;
            max-height: 400px;
            overflow-y: auto;
        }

        .word-item {
            background: #f7fafc;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .word-item:active {
            transform: scale(0.98);
            border-color: #4facfe;
        }

        .word-item.edit-mode {
            background: #fff5e6;
            border-color: #ffd700;
        }

        .word-text {
            font-size: 1.1rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 6px;
        }

        .word-meaning {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .word-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 10px;
        }

        .edit-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .edit-inputs input {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
        }

        .edit-buttons {
            display: flex;
            gap: 6px;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #a0aec0;
            font-size: 1rem;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 15px 10px;
            flex-wrap: wrap;
        }

        .pagination button {
            padding: 8px 12px;
            font-size: 13px;
            min-width: 40px;
        }

        .pagination button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .floating-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 1000;
        }

        .floating-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .floating-btn:active {
            transform: scale(0.95);
        }

        .fab-flashcard { background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 100%); }
        .fab-review    { background: linear-gradient(135deg, #28a745 0%, #20c997 100%); }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }

        .modal-content {
            background-color: white;
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-button {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .flashcard-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            justify-content: space-between;
        }

        .flashcard {
            width: 100%;
            max-width: 500px;
            height: 300px;
            margin: 0 auto;
            perspective: 1000px;
            cursor: pointer;
        }

        .flashcard-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0s;
            transform-style: preserve-3d;
        }

        .flashcard.is-flipped .flashcard-inner { transform: rotateY(180deg); }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            padding: 20px;
            text-align: center;
            word-break: break-word;
        }

        .flashcard-front {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .flashcard-back {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            transform: rotateY(180deg);
        }

        .flashcard-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        .flashcard-nav {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .flashcard-nav button,
        .flashcard-action-btn {
            flex: 1;
            padding: 20px 12px;
            font-size: 16px;
        }

        .flashcard-progress {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #4c51bf;
            margin-bottom: 10px;
        }

        .search-section { margin-bottom: 15px; }

        #searchInput {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
        }

        .word-list-content::-webkit-scrollbar { width: 6px; }
        .word-list-content::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .word-list-content::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        .word-list-content::-webkit-scrollbar-thumb:hover { background: #555; }

        @media (orientation: landscape) and (max-height: 500px) {
            .flashcard { height: 200px; }
            .flashcard-face { font-size: 1.2rem; }
        }

        @media (max-width: 360px) {
            .header h1 { font-size: 1.3rem; }
            .btn { font-size: 12px; padding: 9px 10px; }
            .stat-number { font-size: 1.3rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="theme-button" onclick="toggleTheme()" title="ÌÖåÎßà Î≥ÄÍ≤Ω">üåó</button>
            <button class="reset-button" onclick="resetAllData()" title="Î™®Îì† Îã®Ïñ¥ Ï¥àÍ∏∞Ìôî">√ó</button>
            <h1>üáÆüá© Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥Ïû•</h1>
            <p>Îã®Ïñ¥Î•º ÏûÖÎ†•ÌïòÍ≥† ÌîåÎûòÏãúÏπ¥ÎìúÎ°ú ÌïôÏäµÌïòÏÑ∏Ïöî</p>
        </div>

        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <div class="input-field">
                        <label for="wordInput">Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥</label>
                        <input type="text" id="wordInput" placeholder="Îã®Ïñ¥ ÏûÖÎ†•" autocomplete="off">
                    </div>
                    <div class="input-field">
                        <label for="meaningInput">ÌïúÍ∏Ä Îúª</label>
                        <input type="text" id="meaningInput" placeholder="Îúª ÏûÖÎ†•">
                    </div>
                </div>
                <div class="button-group">
                    <button class="btn" onclick="addWord()">‚ûï Ï∂îÍ∞Ä</button>
                    <button class="btn btn-export" onclick="exportToExcel()">üì• ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
                    <button class="btn btn-export" onclick="document.getElementById('fileInput').click()">üìÇ Í∞ÄÏ†∏Ïò§Í∏∞</button>
                    <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="importFromExcel(event)" style="display: none;">
                </div>
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalWords">0</div>
                    <div class="stat-label">Ï†ÑÏ≤¥</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="memorizedWords">0</div>
                    <div class="stat-label">ÏïîÍ∏∞</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="remainingWords">0</div>
                    <div class="stat-label">ÎÇ®ÏùÄÎã®Ïñ¥</div>
                </div>
            </div>

            <div class="search-section">
                <input type="text" id="searchInput" placeholder="üîç Îã®Ïñ¥ Í≤ÄÏÉâ..." oninput="updateDisplay(this.value)">
            </div>

            <div class="word-lists">
                <div class="word-list">
                    <div class="word-list-header">üìö ÏïîÍ∏∞Ìï† Îã®Ïñ¥</div>
                    <div class="word-list-content" id="notMemorizedList"></div>
                    <div class="pagination" id="notMemPagination"></div>
                </div>

                <div class="word-list">
                    <div class="word-list-header memorized-header">‚úÖ ÏïîÍ∏∞Ìïú Îã®Ïñ¥</div>
                    <div class="word-list-content" id="memorizedList"></div>
                    <div class="pagination" id="memPagination"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="floating-buttons">
        <button class="floating-btn fab-flashcard" id="startNotMemFlashcardBtn" title="ÌîåÎûòÏãúÏπ¥Îìú">üìñ</button>
        <button class="floating-btn fab-review" id="startMemFlashcardBtn" title="Î≥µÏäµÌïòÍ∏∞">üîÑ</button>
    </div>

    <div id="flashcard-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>ÌîåÎûòÏãúÏπ¥Îìú</h2>
                <button class="close-button">&times;</button>
            </div>
            <div class="flashcard-container">
                <div class="flashcard-progress" id="flashcard-progress">1 / 10</div>
                <div class="flashcard" id="flashcard">
                    <div class="flashcard-inner">
                        <div class="flashcard-face flashcard-front" id="flashcard-front">Îã®Ïñ¥</div>
                        <div class="flashcard-face flashcard-back" id="flashcard-back">Îúª</div>
                    </div>
                </div>
                <div class="flashcard-controls">
                    <div class="flashcard-nav">
                        <button class="btn" id="flashcard-prev-btn">‚óÄ Ïù¥Ï†Ñ</button>
                        <button class="btn" id="flashcard-next-btn">Îã§Ïùå ‚ñ∂</button>
                    </div>
                    <button class="btn btn-secondary flashcard-action-btn" id="flashcard-action-btn">ÏïîÍ∏∞ ÏôÑÎ£å</button>
                </div>
            </div>
        </div>
    </div>

<script>
    const vocabulary = { words: [] };
    let nextId = 1;
    let currentFlashcardMode = 'notMemorized';
    let flashcardWords = [];
    let currentFlashcardIndex = 0;

    const ITEMS_PER_PAGE = 10;
    let currentPageNotMem = 1;
    let currentPageMem = 1;

    // ===== Ïú†Ìã∏: ÏïÖÏÑºÌä∏ Ï†úÍ±∞ / Í¥ÑÌò∏ Í≥µÎ∞± Ï≤òÎ¶¨ / Í≤ÄÏÉâÌÇ§ Ï†ïÍ∑úÌôî =====
    function stripDiacritics(str) {
      return String(str).normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    // Í¥ÑÌò∏Î•òÎ•º Ïä§ÌéòÏù¥Ïä§Ï≤òÎüº Ï≤òÎ¶¨ + Í≥µÎ∞±Ï†ïÎ¶¨ (ÏÇ¨Ï†Ñ/Í≤ÄÏÉâ Î™®Îëê Í≥µÌÜµ)
    function toLookupText(raw) {
      let s = stripDiacritics(raw);

      // Í¥ÑÌò∏Î•ò -> Í≥µÎ∞±
      s = s.replace(/[()ÔºªÔºΩ\[\]{}ÔΩõÔΩù<>ÔºúÔºûÔºàÔºâ„Äê„Äë„Äå„Äç„Äé„Äè]/g, ' ');

      // Í≥µÎ∞± Ï†ïÎ¶¨
      s = s.replace(/\s+/g, ' ').trim();
      return s;
    }

    // Í≤ÄÏÉâ/Ï§ëÎ≥µ ÌåêÎã®Ïö© ÌÇ§
    function normalizeKey(str) {
      return toLookupText(str).toLowerCase();
    }

    // ÏÇ¨Ï†Ñ Ïó¥ Îïå Îã®Ïñ¥Î•º Î∂ÑÎ¶¨ (ÎÑàÎ¨¥ ÎßéÏù¥ Ïó¥Î¶¨Î©¥ ÌåùÏóÖ Ï∞®Îã®ÎêòÎØÄÎ°ú Ï†úÌïú)
    function getLookupTerms(raw, max = 2) {
      const cleaned = toLookupText(raw);
      if (!cleaned) return [];
      const terms = cleaned.split(' ').filter(Boolean);
      const uniq = [...new Set(terms)];
      return uniq.slice(0, max);
    }

    // ===== ÌÖåÎßà =====
    function applyThemeFromStorage() {
        const theme = localStorage.getItem('themeMode') || 'color';
        document.body.classList.toggle('mono-mode', theme === 'mono');
    }

    function toggleTheme() {
        const isMono = document.body.classList.toggle('mono-mode');
        localStorage.setItem('themeMode', isMono ? 'mono' : 'color');
    }

    // ===== Ï†ÄÏû•/Î°úÎìú =====
    function formatDate(date) {
        const d = new Date(date);
        const year = d.getFullYear();
        const month = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    function saveToStorage() {
        localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
        localStorage.setItem('nextId', nextId.toString());
    }

    function loadFromStorage() {
        const stored = localStorage.getItem('vocabulary');
        if (stored) {
            const parsed = JSON.parse(stored);
            vocabulary.words = parsed.words || [];
        }
        const storedId = localStorage.getItem('nextId');
        if (storedId) nextId = parseInt(storedId, 10);
    }

    loadFromStorage();
    applyThemeFromStorage();

    // ===== ÏûÖÎ†•ÌïÑÎìú Í∏∞Î∞ò Ï¶âÏãúÍ≤ÄÏÉâ =====
    function updateSearchFromWordInput() {
        const wordInputValue = document.getElementById('wordInput').value;
        const searchInputValue = document.getElementById('searchInput').value;

        if (wordInputValue.trim()) {
            updateDisplay(wordInputValue);
        } else {
            updateDisplay(searchInputValue);
        }
    }
    document.getElementById('wordInput').addEventListener('input', updateSearchFromWordInput);

    // ===== Îã®Ïñ¥ CRUD =====
    function addWord() {
        const wordInput = document.getElementById('wordInput');
        const meaningInput = document.getElementById('meaningInput');
        const word = wordInput.value.trim();
        const meaning = meaningInput.value.trim();

        if (word && meaning) {
            const isDuplicate = vocabulary.words.some(w => normalizeKey(w.word) === normalizeKey(word));
            if (isDuplicate) {
                alert('Ïù¥ÎØ∏ Îì±Î°ùÎêú Îã®Ïñ¥ÏûÖÎãàÎã§.');
                wordInput.focus();
                return;
            }

            vocabulary.words.push({
                id: nextId++,
                word,
                meaning,
                memorized: false,
                addedDate: new Date().toISOString()
            });

            wordInput.value = '';
            meaningInput.value = '';
            wordInput.focus();
            saveToStorage();
            updateDisplay(document.getElementById('searchInput').value);
        } else {
            alert('Îã®Ïñ¥ÏôÄ ÎúªÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
        }
    }

    function toggleMemorized(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (word) {
            word.memorized = !word.memorized;
            saveToStorage();
            updateDisplay();
        }
    }

    function deleteWord(id) {
        if (confirm('Ï†ïÎßê ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
            vocabulary.words = vocabulary.words.filter(w => w.id !== id);
            saveToStorage();
            updateDisplay();
        }
    }

    function resetAllData() {
        if (confirm('Ï†ïÎßê Î™®Îì† Îã®Ïñ¥Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?\nÏù¥ ÏûëÏóÖÏùÄ ÎêòÎèåÎ¶¥ Ïàò ÏóÜÏäµÎãàÎã§.')) {
            if (confirm('ÏµúÏ¢Ö ÌôïÏù∏: Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏòÅÍµ¨Ï†ÅÏúºÎ°ú ÏÇ≠Ï†úÎê©ÎãàÎã§.')) {
                vocabulary.words = [];
                nextId = 1;
                saveToStorage();
                updateDisplay();
                alert('Î™®Îì† Îã®Ïñ¥Í∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.');
            }
        }
    }

    // ===== Ìé∏Ïßë =====
    function enterEditMode(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (!word) return;

        const wordItem = document.querySelector(`[data-word-id="${id}"]`);
        if (!wordItem) return;

        wordItem.classList.add('edit-mode');
        wordItem.innerHTML = `
            <div class="edit-inputs" onclick="event.stopPropagation()">
                <input type="text" id="edit-word-${id}" value="${word.word}">
                <input type="text" id="edit-meaning-${id}" value="${word.meaning}">
            </div>
            <div class="edit-buttons">
                <button class="btn btn-small" onclick="event.stopPropagation(); saveEdit(${id})">Ï†ÄÏû•</button>
                <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); cancelEdit(${id})">Ï∑®ÏÜå</button>
            </div>
        `;

        setTimeout(() => {
            const el = document.getElementById(`edit-word-${id}`);
            if (el) el.focus();
        }, 0);
    }

    function saveEdit(id) {
        const wordInput = document.getElementById(`edit-word-${id}`);
        const meaningInput = document.getElementById(`edit-meaning-${id}`);
        if (!wordInput || !meaningInput) return;

        const newWord = wordInput.value.trim();
        const newMeaning = meaningInput.value.trim();

        if (!newWord || !newMeaning) {
            alert('Îã®Ïñ¥ÏôÄ ÎúªÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }

        const isDuplicate = vocabulary.words.some(w => w.id !== id && normalizeKey(w.word) === normalizeKey(newWord));
        if (isDuplicate) {
            alert('Ïù¥ÎØ∏ Îì±Î°ùÎêú Îã®Ïñ¥ÏûÖÎãàÎã§.');
            return;
        }

        const word = vocabulary.words.find(w => w.id === id);
        if (word) {
            word.word = newWord;
            word.meaning = newMeaning;
            saveToStorage();
            updateDisplay(document.getElementById('searchInput').value);
        }
    }

    function cancelEdit() {
        updateDisplay(document.getElementById('searchInput').value);
    }

    // ===== ÌÜµÍ≥Ñ/Ï†ïÎ†¨/ÌéòÏù¥ÏßÄ =====
    function updateStats() {
        document.getElementById('totalWords').textContent = vocabulary.words.length;
        const memorizedCount = vocabulary.words.filter(w => w.memorized).length;
        document.getElementById('memorizedWords').textContent = memorizedCount;
        document.getElementById('remainingWords').textContent = vocabulary.words.length - memorizedCount;
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function renderPagination(containerId, totalItems, currentPage, type) {
        const container = document.getElementById(containerId);
        const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);

        if (totalPages <= 1) {
            container.innerHTML = '';
            return;
        }

        let html = '';
        if (currentPage > 1) {
            html += `<button class="btn btn-small" onclick="changePage('${type}', ${currentPage - 1})">‚óÄ</button>`;
        }

        const startPage = Math.max(1, currentPage - 2);
        const endPage = Math.min(totalPages, currentPage + 2);

        if (startPage > 1) {
            html += `<button class="btn btn-small" onclick="changePage('${type}', 1)">1</button>`;
            if (startPage > 2) html += '<span>...</span>';
        }

        for (let i = startPage; i <= endPage; i++) {
            html += `<button class="btn btn-small ${i === currentPage ? 'active' : ''}" onclick="changePage('${type}', ${i})">${i}</button>`;
        }

        if (endPage < totalPages) {
            if (endPage < totalPages - 1) html += '<span>...</span>';
            html += `<button class="btn btn-small" onclick="changePage('${type}', ${totalPages})">${totalPages}</button>`;
        }

        if (currentPage < totalPages) {
            html += `<button class="btn btn-small" onclick="changePage('${type}', ${currentPage + 1})">‚ñ∂</button>`;
        }

        container.innerHTML = html;
    }

    function changePage(type, page) {
        if (type === 'notMem') currentPageNotMem = page;
        else currentPageMem = page;
        updateDisplay(document.getElementById('searchInput').value);
    }

    function updateDisplay(searchTerm = '') {
        const key = normalizeKey(searchTerm);

        const filteredWords = vocabulary.words.filter(word => {
            const w = normalizeKey(word.word);
            const m = normalizeKey(word.meaning);
            return w.includes(key) || m.includes(key);
        });

        const notMemorized = filteredWords.filter(w => !w.memorized);
        const memorized = filteredWords.filter(w => w.memorized);

        shuffleArray(notMemorized);
        shuffleArray(memorized);

        updateStats();

        const renderList = (container, data, paginatedData) => {
            container.innerHTML = data.length === 0
                ? '<div class="empty-state">Ìï¥Îãπ Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.</div>'
                : paginatedData.map(word => `
                    <div class="word-item" data-word-id="${word.id}"
                        onclick="if (!event.target.closest('.word-actions')) enterEditMode(${word.id})">
                        <div class="word-text">${word.word}</div>
                        <div class="word-meaning">${word.meaning}</div>
                        <div class="word-actions">
                            <button class="btn btn-small" onclick="event.stopPropagation(); toggleMemorized(${word.id})">
                                ${word.memorized ? 'ÏïîÍ∏∞ Ï∑®ÏÜå' : 'ÏïîÍ∏∞ ÏôÑÎ£å'}
                            </button>
                            <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); deleteWord(${word.id})">ÏÇ≠Ï†ú</button>
                            <button class="btn btn-small btn-edit" onclick="event.stopPropagation(); enterEditMode(${word.id})" title="ÏàòÏ†ï">‚úèÔ∏è</button>
                            <button class="btn btn-small btn-kbbi" onclick="event.stopPropagation(); showKBBI(${word.id})">KBBI</button>
                            <button class="btn btn-small btn-naver" onclick="event.stopPropagation(); showNaver(${word.id})">Naver</button>
                            <button class="btn btn-small btn-daum" onclick="event.stopPropagation(); showDaum(${word.id})">Daum</button>
                        </div>
                    </div>`).join('');
        };

        const notMemorizedList = document.getElementById('notMemorizedList');
        const paginatedNotMem = notMemorized.slice((currentPageNotMem - 1) * ITEMS_PER_PAGE, currentPageNotMem * ITEMS_PER_PAGE);
        renderList(notMemorizedList, notMemorized, paginatedNotMem);
        renderPagination('notMemPagination', notMemorized.length, currentPageNotMem, 'notMem');

        const memorizedList = document.getElementById('memorizedList');
        const paginatedMem = memorized.slice((currentPageMem - 1) * ITEMS_PER_PAGE, currentPageMem * ITEMS_PER_PAGE);
        renderList(memorizedList, memorized, paginatedMem);
        renderPagination('memPagination', memorized.length, currentPageMem, 'mem');
    }

    // ===== ÏÇ¨Ï†Ñ ÎßÅÌÅ¨ =====
    function showKBBI(id) {
      const item = vocabulary.words.find(w => w.id === id);
      if (!item) return;

      const terms = getLookupTerms(item.word, 2);
      if (terms.length <= 1) {
        const q = toLookupText(item.word);
        window.open(`https://kbbi.web.id/${encodeURIComponent(q)}`, '_blank');
        return;
      }
      terms.forEach(t => window.open(`https://kbbi.web.id/${encodeURIComponent(t)}`, '_blank'));
    }

    function showNaver(id) {
      const item = vocabulary.words.find(w => w.id === id);
      if (!item) return;

      const terms = getLookupTerms(item.word, 2);
      if (terms.length <= 1) {
        const q = toLookupText(item.word);
        window.open(`https://dict.naver.com/idkodict/#/search?query=${encodeURIComponent(q)}`, '_blank');
        return;
      }
      terms.forEach(t => window.open(`https://dict.naver.com/idkodict/#/search?query=${encodeURIComponent(t)}`, '_blank'));
    }

    // Daum: ÏÇ¨Ïù¥Ìä∏ ÏûêÏ≤¥ Ïù¥Ïäà(Í∂åÌïúÏóÜÏùå/Î¶¨Îã§Ïù¥Î†âÌä∏ Íº¨ÏûÑ) ÎßéÏïÑÏÑú
    // ÏûêÎèô Ïû¨ÏãúÎèÑ + fallback(Îã§Ïùå ÌÜµÌï©Í≤ÄÏÉâ) Ï†ÑÎûµ
    function openDaumWithAutoRetryAndFallback(query) {
      const q = encodeURIComponent(query);
      const url = `https://dic.daum.net/search.do?q=${q}&dic=id`;
      const fallback = `https://search.daum.net/search?w=tot&q=${q}%20%EB%9C%BB`;

      const w = window.open(url, '_blank');
      if (!w) {
        alert('ÌåùÏóÖÏù¥ Ï∞®Îã®ÎêòÏñ¥ Daum ÏÇ¨Ï†ÑÏùÑ Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§. ÌåùÏóÖ ÌóàÏö© ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      // ÏóîÌÑ∞ Ìïú Î≤à Îçî ÎåÄÏã† (ÏÑ∏ÏÖò/Ïø†ÌÇ§ Ïû°ÌûàÎ©¥ Î≥¥ÌÜµ Ï†ïÏÉÅ)
      setTimeout(() => { try { w.location.href = url; } catch(e) {} }, 800);

      // Í∑∏ÎûòÎèÑ Íº¨Ïù¥Î©¥ ÌÜµÌï©Í≤ÄÏÉâÏúºÎ°ú Ïö∞Ìöå
      setTimeout(() => { try { w.location.href = fallback; } catch(e) {} }, 2500);
    }

    function showDaum(id) {
      const item = vocabulary.words.find(w => w.id === id);
      if (!item) return;

      const terms = getLookupTerms(item.word, 2);
      if (terms.length <= 1) {
        openDaumWithAutoRetryAndFallback(toLookupText(item.word));
        return;
      }
      terms.forEach(t => openDaumWithAutoRetryAndFallback(t));
    }

    // ===== Excel =====
    function exportToExcel() {
        if (vocabulary.words.length === 0) {
            alert('ÎÇ¥Î≥¥ÎÇº Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.');
            return;
        }

        const data = vocabulary.words.map(w => ({
            'Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥': w.word,
            'ÌïúÍ∏Ä Îúª': w.meaning,
            'ÏïîÍ∏∞ Ïó¨Î∂Ä': w.memorized,
            'Ï∂îÍ∞Ä ÎÇ†Ïßú': formatDate(w.addedDate)
        }));

        const ws = XLSX.utils.json_to_sheet(data);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Îã®Ïñ¥Ïû•');
        XLSX.writeFile(wb, 'Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥_Îã®Ïñ¥Ïû•.xlsx');
    }

    function importFromExcel(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                let importCount = 0;
                let duplicateCount = 0;

                jsonData.forEach(row => {
                    const word = row['Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥'] || row['word'] || row['Word'];
                    const meaning = row['ÌïúÍ∏Ä Îúª'] || row['meaning'] || row['Meaning'];
                    const memorizedRaw = row['ÏïîÍ∏∞ Ïó¨Î∂Ä'];
                    const memorized = memorizedRaw === true ||
                                      memorizedRaw === 'true' ||
                                      memorizedRaw === 'TRUE' ||
                                      memorizedRaw === 'True' ||
                                      memorizedRaw === 1 ||
                                      memorizedRaw === '1' ||
                                      memorizedRaw === 'O' ||
                                      memorizedRaw === 'o' ||
                                      memorizedRaw === 'Y' ||
                                      memorizedRaw === 'y' ||
                                      memorizedRaw === 'yes' ||
                                      memorizedRaw === 'YES';
                    const addedDate = row['Ï∂îÍ∞Ä ÎÇ†Ïßú'] || row['date'] || row['Date'];

                    if (word && meaning) {
                        const wtxt = String(word).trim();
                        const isDuplicate = vocabulary.words.some(w => normalizeKey(w.word) === normalizeKey(wtxt));

                        if (isDuplicate) {
                            duplicateCount++;
                        } else {
                            vocabulary.words.push({
                                id: nextId++,
                                word: wtxt,
                                meaning: String(meaning).trim(),
                                memorized,
                                addedDate: addedDate ? new Date(addedDate).toISOString() : new Date().toISOString()
                            });
                            importCount++;
                        }
                    }
                });

                if (importCount > 0 || duplicateCount > 0) {
                    saveToStorage();
                    updateDisplay();
                    let message = `${importCount}Í∞úÏùò Îã®Ïñ¥Î•º Î∂àÎü¨ÏôîÏäµÎãàÎã§.`;
                    if (duplicateCount > 0) message += `\n${duplicateCount}Í∞úÏùò Ï§ëÎ≥µ Îã®Ïñ¥Îäî Ï†úÏô∏ÎêòÏóàÏäµÎãàÎã§.`;
                    alert(message);
                } else {
                    alert('Í∞ÄÏ†∏Ïò¨ Ïàò ÏûàÎäî Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.');
                }
            } catch (error) {
                alert('ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
                console.error(error);
            }
            event.target.value = '';
        };
        reader.readAsArrayBuffer(file);
    }

    // ===== ÌîåÎûòÏãúÏπ¥Îìú =====
    const flashcardModal = document.getElementById('flashcard-modal');

    function startFlashcardSession(mode) {
        currentFlashcardMode = mode;
        flashcardWords = (mode === 'notMemorized')
            ? vocabulary.words.filter(w => !w.memorized)
            : vocabulary.words.filter(w => w.memorized);

        if (flashcardWords.length === 0) {
            alert(mode === 'notMemorized' ? 'ÌîåÎûòÏãúÏπ¥ÎìúÎ°ú ÌïôÏäµÌï† Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.' : 'Î≥µÏäµÌï† ÏïîÍ∏∞Ìïú Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.');
            return;
        }

        shuffleArray(flashcardWords);
        currentFlashcardIndex = 0;
        flashcardModal.style.display = 'block';
        displayFlashcard();
    }

    function displayFlashcard() {
        if (flashcardWords.length === 0) {
            closeFlashcardModal();
            return;
        }

        const word = flashcardWords[currentFlashcardIndex];
        document.getElementById('flashcard-progress').textContent = `${currentFlashcardIndex + 1} / ${flashcardWords.length}`;
        document.getElementById('flashcard-front').textContent = word.word;
        document.getElementById('flashcard-back').textContent = word.meaning;
        document.getElementById('flashcard').classList.remove('is-flipped');

        const actionBtn = document.getElementById('flashcard-action-btn');
        if (currentFlashcardMode === 'notMemorized') {
            actionBtn.textContent = 'ÏïîÍ∏∞ ÏôÑÎ£å';
            actionBtn.className = 'btn btn-secondary flashcard-action-btn';
        } else {
            actionBtn.textContent = 'Îã§Ïãú ÏïîÍ∏∞ÌïòÍ∏∞';
            actionBtn.className = 'btn btn-review flashcard-action-btn';
        }
    }

    function showNextFlashcard() {
        if (flashcardWords.length === 0) return;
        currentFlashcardIndex = (currentFlashcardIndex + 1) % flashcardWords.length;
        displayFlashcard();
    }

    function showPrevFlashcard() {
        if (flashcardWords.length === 0) return;
        currentFlashcardIndex = (currentFlashcardIndex - 1 + flashcardWords.length) % flashcardWords.length;
        displayFlashcard();
    }

    function handleFlashcardAction() {
        if (flashcardWords.length === 0) return;

        const currentWord = flashcardWords[currentFlashcardIndex];
        const originalWord = vocabulary.words.find(w => w.id === currentWord.id);

        if (originalWord) originalWord.memorized = !originalWord.memorized;

        flashcardWords.splice(currentFlashcardIndex, 1);

        if (currentFlashcardIndex >= flashcardWords.length && flashcardWords.length > 0) {
            currentFlashcardIndex = 0;
        }

        displayFlashcard();
    }

    function closeFlashcardModal() {
        flashcardModal.style.display = 'none';
        saveToStorage();
        updateDisplay();
    }

    // ===== Ïù¥Î≤§Ìä∏ =====
    document.getElementById('startNotMemFlashcardBtn').addEventListener('click', () => startFlashcardSession('notMemorized'));
    document.getElementById('startMemFlashcardBtn').addEventListener('click', () => startFlashcardSession('memorized'));

    flashcardModal.querySelector('.close-button').addEventListener('click', closeFlashcardModal);
    document.getElementById('flashcard').addEventListener('click', () =>
        document.getElementById('flashcard').classList.toggle('is-flipped')
    );
    document.getElementById('flashcard-next-btn').addEventListener('click', showNextFlashcard);
    document.getElementById('flashcard-prev-btn').addEventListener('click', showPrevFlashcard);
    document.getElementById('flashcard-action-btn').addEventListener('click', handleFlashcardAction);

    document.getElementById('wordInput').addEventListener('keypress', e => {
        if (e.key === 'Enter') document.getElementById('meaningInput').focus();
    });
    document.getElementById('meaningInput').addEventListener('keypress', e => {
        if (e.key === 'Enter') addWord();
    });

    // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Ïóê addedDateÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ Ï∂îÍ∞Ä
    vocabulary.words.forEach(word => {
        if (!word.addedDate) word.addedDate = new Date().toISOString();
    });
    saveToStorage();

    updateDisplay();
</script>
</body>
</html>
