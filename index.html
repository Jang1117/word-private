<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥ ÏïîÍ∏∞ Ïï±</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1046px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: visible; /* ÌîåÎ°úÌåÖ Î≤ÑÌäºÏù¥ ÏûòÎ¶¨ÏßÄ ÏïäÎèÑÎ°ù Î≥ÄÍ≤Ω */
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .content {
            padding: 30px;
        }

        .input-section {
            background: #f8f9ff;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid #e3e8ff;
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .input-field {
            flex: 1;
            min-width: 200px;
        }

        .input-field label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4c51bf;
        }

        .input-field input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .input-field input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            margin-right: 10px;
            margin-top: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.6);
        }
        
        .btn-quiz { /* Flashcard button style */
            background: linear-gradient(135deg, #ff7e5f 0%, #feb47b 100%);
            box-shadow: 0 4px 15px rgba(255, 126, 95, 0.4);
        }

        .btn-quiz:hover {
            box-shadow: 0 8px 25px rgba(255, 126, 95, 0.6);
        }

        .btn-review {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%) !important;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4) !important;
        }

        .btn-review:hover {
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.6) !important;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(255, 107, 107, 0.6);
        }

        .btn-export {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }

        .btn-export:hover {
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.6);
        }

        .btn-edit {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            color: #333;
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        }

        .btn-edit:hover {
            box-shadow: 0 8px 25px rgba(255, 215, 0, 0.6);
        }

        .btn-kbbi {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-daum {
            background: linear-gradient(135deg, #007bff 0%, #00bfff 100%);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #4a5568;
            font-weight: 600;
        }

        .word-lists {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(455px, 1fr));
            gap: 30px;
        }

        .word-list {
            background: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .word-list-header {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #2d3748;
            padding: 20px;
            font-weight: 700;
            font-size: 1.2rem;
            text-align: center;
        }

        .memorized-header {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
        }

        .word-item {
            padding: 15px 20px;
            border-bottom: 1px solid #e2e8f0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .word-item:hover {
            background: #f7fafc;
            transform: translateX(5px);
        }

        .word-item.edit-mode {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .word-item:last-child {
            border-bottom: none;
        }

        .word-text {
            font-weight: 600;
            color: #2d3748;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .word-meaning {
            color: #4a5568;
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .word-actions {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 14px;
            border-radius: 6px;
        }

        .empty-state {
            text-align: center;
            color: #a0aec0;
            padding: 40px 20px;
            font-style: italic;
        }

        .search-section {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            font-size: 16px;
            margin-bottom: 15px;
        }

        .edit-input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ffc107;
            border-radius: 6px;
            font-size: 1rem;
            margin-bottom: 5px;
            background: white;
        }

        .edit-input:focus {
            outline: none;
            border-color: #e0a800;
            box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.1);
        }

        /* --- ‚ú® REQUESTED CHANGE: FLOATING PAGINATION STYLES --- */
        #notMemPagination, #memPagination {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
            background: rgba(248, 249, 250, 0.9);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: auto;
            border: 1px solid #e9ecef;
        }

        #notMemPagination {
            left: 20px;
        }

        #memPagination {
            right: 20px;
        }
        
        .pagination button {
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }

        .pagination button:hover:not(:disabled) {
            background: #e9ecef;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #notMemPagination .page-numbers,
        #memPagination .page-numbers {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .pagination .page-numbers button.active {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        /* --- END OF CHANGE --- */


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s;
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 30px;
            border: 1px solid #888;
            width: 90%;
            max-width: 500px;
            border-radius: 15px;
            text-align: center;
            position: relative;
            animation: slideIn 0.3s;
        }
        
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideIn { from { transform: translateY(-30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .close-button {
            color: #aaa;
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        /* --- Flashcard Modal Styles --- */
        .flashcard-scene {
            width: 100%;
            height: 200px;
            perspective: 1000px;
            margin: 20px 0;
        }

        #flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            cursor: pointer;
        }

        #flashcard.is-flipped {
            transform: rotateY(180deg);
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            font-weight: bold;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            padding: 15px;
            overflow-wrap: break-word;
        }

        #flashcard-front {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #2d3748;
        }

        #flashcard-back {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: rotateY(180deg);
        }

        .flashcard-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }

        #flashcard-progress {
            font-weight: 600;
            color: #4a5568;
            font-size: 1.1rem;
        }

        @media (max-width: 900px) { /* Breakpoint for floating pagination */
            #notMemPagination, #memPagination {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            .word-lists {
                grid-template-columns: 1fr;
            }
            .modal-content {
                margin: 25% auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìö Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥ ÏïîÍ∏∞</h1>
            <p>Îã®Ïñ¥Î•º Ï∂îÍ∞ÄÌïòÍ≥† ÏïîÍ∏∞ ÏÉÅÌÉúÎ•º Í¥ÄÎ¶¨ÌïòÏÑ∏Ïöî</p>
        </div>
        
        <div class="content">
            <div class="input-section">
                <div class="input-group">
                    <div class="input-field">
                        <label for="wordInput">Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥</label>
                        <input type="text" id="wordInput" placeholder="Ïòà: rumah">
                    </div>
                    <div class="input-field">
                        <label for="meaningInput">ÌïúÍµ≠Ïñ¥ Îúª</label>
                        <input type="text" id="meaningInput" placeholder="Ïòà: Ïßë">
                    </div>
                </div>
                <button class="btn" onclick="addWord()">Îã®Ïñ¥ Ï∂îÍ∞Ä</button>
                <button class="btn" onclick="document.getElementById('excelFile').click()" title="Excel ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏó¨ Ïó¨Îü¨ Îã®Ïñ¥Î•º Ìïú Î≤àÏóê Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî. (Ïª¨Îüº: 'Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥', 'ÌïúÍµ≠Ïñ¥ Îúª')">üìä Excel ÏóÖÎ°úÎìú</button>
                <button class="btn btn-export" onclick="exportToExcel()" title="ÌòÑÏû¨ Îã®Ïñ¥ Î™©Î°ùÏùÑ Excel ÌååÏùºÎ°ú Îã§Ïö¥Î°úÎìúÌïòÏÑ∏Ïöî.">üì• Excel Ï†ÄÏû•</button>
                
                <button id="startNotMemFlashcardBtn" class="btn btn-quiz">üìá ÏïîÍ∏∞Ìï† Îã®Ïñ¥ ÌïôÏäµ</button>
                <button id="startMemFlashcardBtn" class="btn btn-review">üîÅ ÏïîÍ∏∞Ìïú Îã®Ïñ¥ Î≥µÏäµ</button>

                <input type="file" id="excelFile" accept=".xlsx,.xls" style="display: none;">
            </div>

            <div class="stats">
                <div class="stat-card">
                    <div class="stat-number" id="totalWords">0</div>
                    <div class="stat-label">Ï¥ù Îã®Ïñ¥</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="memorizedWords">0</div>
                    <div class="stat-label">ÏïîÍ∏∞Ìïú Îã®Ïñ¥</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="remainingWords">0</div>
                    <div class="stat-label">ÎÇ®ÏùÄ Îã®Ïñ¥</div>
                </div>
            </div>

            <div class="search-section">
                <input type="text" class="search-input" id="searchInput" placeholder="Îã®Ïñ¥ Í≤ÄÏÉâ..." onkeyup="filterWords()">
            </div>

            <div class="word-lists">
                <div class="word-list">
                    <div class="word-list-header">üìù ÏïîÍ∏∞Ìï† Îã®Ïñ¥</div>
                    <div id="notMemorizedList">
                        <div class="empty-state">ÏïÑÏßÅ Ï∂îÍ∞ÄÎêú Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.</div>
                    </div>
                </div>
                
                <div class="word-list">
                    <div class="word-list-header memorized-header">‚úÖ ÏïîÍ∏∞Ìïú Îã®Ïñ¥</div>
                    <div id="memorizedList">
                        <div class="empty-state">ÏïîÍ∏∞Ìïú Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Floating Pagination Containers -->
    <div class="pagination" id="notMemPagination"></div>
    <div class="pagination" id="memPagination"></div>
    
    <!-- Flashcard Modal -->
    <div id="flashcard-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <div id="flashcard-progress"></div>
            <div class="flashcard-scene">
                <div id="flashcard">
                    <div id="flashcard-front" class="flashcard-face"></div>
                    <div id="flashcard-back" class="flashcard-face"></div>
                </div>
            </div>
            <div class="flashcard-controls">
                <button class="btn" id="flashcard-prev-btn">Ïù¥Ï†Ñ</button>
                <button class="btn btn-secondary" id="flashcard-action-btn"></button>
                <button class="btn" id="flashcard-next-btn">Îã§Ïùå</button>
            </div>
        </div>
    </div>


<script>
    let vocabulary = { words: [], nextId: 1 };
    let currentPageNotMem = 1;
    let currentPageMem = 1;
    const ITEMS_PER_PAGE = 100;
    let flashcardWords = [];
    let currentFlashcardIndex = 0;
    let currentFlashcardMode = 'notMemorized';

    function loadFromStorage() {
        const saved = localStorage.getItem('vocabulary');
        if (saved) {
            const parsed = JSON.parse(saved);
            vocabulary.words = parsed.words || [];
            vocabulary.nextId = parsed.nextId || 1;
        }
    }

    function saveToStorage() {
        localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
    }

    loadFromStorage();

    function addWord() {
        const wordInput = document.getElementById('wordInput');
        const meaningInput = document.getElementById('meaningInput');
        const word = wordInput.value.trim().toLowerCase();
        const meaning = meaningInput.value.trim();
        
        if (!word || !meaning) {
            alert('Îã®Ïñ¥ÏôÄ ÎúªÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }
        if (vocabulary.words.some(w => w.word === word)) {
            alert('Ïù¥ÎØ∏ Ï∂îÍ∞ÄÎêú Îã®Ïñ¥ÏûÖÎãàÎã§.');
            return;
        }
        
        vocabulary.words.push({
            id: vocabulary.nextId++,
            word: word,
            meaning: meaning,
            memorized: false,
            addedDate: new Date().toLocaleDateString()
        });
        wordInput.value = '';
        meaningInput.value = '';
        updateDisplay();
        saveToStorage();
        alert('Îã®Ïñ¥Í∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!');
    }

    // ‚úÖ ÏïîÍ∏∞ Ïó¨Î∂ÄÎ•º true/falseÎ°ú Ï†ÄÏû•Ìï¥ÏÑú Îçî ÌôïÏã§ÌïòÍ≤å
    function exportToExcel() {
        if (vocabulary.words.length === 0) {
            alert('ÎÇ¥Î≥¥ÎÇº Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.');
            return;
        }

        const rows = vocabulary.words.map(w => ({
            'Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥': w.word,
            'ÌïúÍµ≠Ïñ¥ Îúª': w.meaning,
            'ÏïîÍ∏∞ Ïó¨Î∂Ä': w.memorized, // true / false Î°ú Ï†ÄÏû•
            'Ï∂îÍ∞Ä ÎÇ†Ïßú': w.addedDate || ''
        }));

        const ws = XLSX.utils.json_to_sheet(rows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, 'Îã®Ïñ¥ Î™©Î°ù');
        XLSX.writeFile(
            wb,
            `Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥_Îã®Ïñ¥_Î™©Î°ù_${new Date().toISOString().split('T')[0]}.xlsx`
        );
        alert('Excel ÌååÏùºÎ°ú Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!');
    }

    // ‚úÖ ÏïîÍ∏∞ Ïó¨Î∂Ä Í∞í ÌååÏã± (true / false / 1 / 0 / Î¨∏ÏûêÏó¥ Îì± Ï≤òÎ¶¨)
    function parseMemorized(value) {
        if (value === true) return true;
        if (value === false) return false;

        if (typeof value === 'number') {
            if (value === 1) return true;
            if (value === 0) return false;
        }

        const str = (value || '').toString().trim().toLowerCase();
        if (str === 'true' || str === '1' || str === 'o' || str === 'yes') return true;
        if (str === 'false' || str === '0' || str === 'x' || str === 'no' || str === '') return false;

        // Ïûò Î™®Î•¥Îäî Í∞íÏù¥Î©¥ ÏùºÎã® falseÎ°ú
        return false;
    }

    // ‚úÖ ÏóëÏÖÄ ÏóÖÎ°úÎìú: ÏïîÍ∏∞ Ïó¨Î∂Ä/Ï∂îÍ∞Ä ÎÇ†ÏßúÍπåÏßÄ Î≥µÏõê
    document.getElementById('excelFile').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (!file) return;
        if (!file.name.match(/\.(xlsx|xls)$/)) {
            alert('Excel ÌååÏùº(.xlsx ÎòêÎäî .xls)ÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }
        try {
            const data = await file.arrayBuffer();
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(sheet);
            if (json.length === 0) {
                alert('Excel ÌååÏùºÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const headers = Object.keys(json[0] || {});
            if (!headers.includes('Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥') || !headers.includes('ÌïúÍµ≠Ïñ¥ Îúª')) {
                alert('Excel ÌååÏùºÏóê "Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥"ÏôÄ "ÌïúÍµ≠Ïñ¥ Îúª" Ïª¨ÎüºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
                return;
            }

            let addedCount = 0, skippedCount = 0;
            for (let row of json) {
                const word = (row['Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥'] || '').toString().trim().toLowerCase();
                const meaning = (row['ÌïúÍµ≠Ïñ¥ Îúª'] || '').toString().trim();

                if (!word || !meaning || vocabulary.words.some(w => w.word === word)) {
                    skippedCount++;
                    continue;
                }

                // ÏïîÍ∏∞ Ïó¨Î∂Ä true/false Î≥µÏõê
                const memorized = parseMemorized(row['ÏïîÍ∏∞ Ïó¨Î∂Ä']);

                // Ï∂îÍ∞Ä ÎÇ†Ïßú Î≥µÏõê (ÏóÜÏúºÎ©¥ Ïò§Îäò ÎÇ†Ïßú)
                const addedDateCell = (row['Ï∂îÍ∞Ä ÎÇ†Ïßú'] || '').toString().trim();
                const addedDate = addedDateCell || new Date().toLocaleDateString();

                vocabulary.words.push({
                    id: vocabulary.nextId++,
                    word: word,
                    meaning: meaning,
                    memorized: memorized,
                    addedDate: addedDate
                });
                addedCount++;
            }
            updateDisplay();
            saveToStorage();
            alert(`${addedCount}Í∞úÏùò Îã®Ïñ¥Í∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§! (Ï§ëÎ≥µ/Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ${skippedCount}Í∞ú Í±¥ÎÑàÎúÄ)`);
        } catch (error) {
            console.error('Excel ÏóÖÎ°úÎìú Ïò§Î•ò:', error);
            alert('Excel ÌååÏùºÏùÑ ÏùΩÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
        } finally {
            e.target.value = '';
        }
    });

    function toggleMemorized(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (word) {
            word.memorized = !word.memorized;
            updateDisplay();
            saveToStorage();
        }
    }

    function deleteWord(id) {
        if (confirm('Ï†ïÎßêÎ°ú Ïù¥ Îã®Ïñ¥Î•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
            vocabulary.words = vocabulary.words.filter(w => w.id !== id);
            updateDisplay();
            saveToStorage();
        }
    }

    function filterWords() {
        currentPageNotMem = 1;
        currentPageMem = 1;
        updateDisplay(document.getElementById('searchInput').value.toLowerCase());
    }

    function goToPage(listType, page) {
        if (listType === 'notMem') currentPageNotMem = page;
        else currentPageMem = page;
        updateDisplay();
    }

    function renderPagination(containerId, totalItems, currentPage, listType) {
        const container = document.getElementById(containerId);
        const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE);
        container.innerHTML = '';
        if (totalPages <= 1) return;
        
        const pages = [];
        const maxButtons = 5; // Reduced for vertical layout
        if (totalPages <= maxButtons) {
            for (let i = 1; i <= totalPages; i++) pages.push(i);
        } else {
            pages.push(1);
            let startPage = Math.max(2, currentPage - 1), endPage = Math.min(totalPages - 1, currentPage + 1);
            if (currentPage <= 3) { startPage = 2; endPage = 4; }
            if (currentPage > totalPages - 3) { startPage = totalPages - 3; endPage = totalPages - 1; }
            if (startPage > 2) pages.push('...');
            for (let i = startPage; i <= endPage; i++) pages.push(i);
            if (endPage < totalPages - 1) pages.push('...');
            pages.push(totalPages);
        }
        
        let pageNumbersHtml = pages.map(p => 
            p === '...' 
                ? `<span style="padding: 8px 4px; color: #6c757d; font-weight: bold; align-self: center;">...</span>`
                : `<button class="${p === currentPage ? 'active' : ''}" onclick="goToPage('${listType}', ${p})">${p}</button>`
        ).join('');
        const prevButtonHtml = `<button onclick="goToPage('${listType}', ${currentPage - 1})" ${currentPage <= 1 ? 'disabled' : ''}>‚ñ≤</button>`;
        const nextButtonHtml = `<button onclick="goToPage('${listType}', ${currentPage + 1})" ${currentPage >= totalPages ? 'disabled' : ''}>‚ñº</button>`;
        container.innerHTML = `${prevButtonHtml}<div class="page-numbers">${pageNumbersHtml}</div>${nextButtonHtml}`;
    }

    function enterEditMode(id) {
        setTimeout(() => {
            const word = vocabulary.words.find(w => w.id === id);
            if (!word) return;
            const wordItem = document.querySelector(`[data-word-id="${id}"]`);
            if (!wordItem) return;

            word.originalWord = word.originalWord ?? word.word;
            word.originalMeaning = word.originalMeaning ?? word.meaning;

            wordItem.classList.add('edit-mode');
            wordItem.innerHTML = `
                <input type="text" class="edit-input" value="${word.word}" 
                    oninput="updateWordTemp(${id}, this.value, 'word')" 
                    onkeydown="if(event.key==='Enter'){saveEdit(${id}); event.preventDefault();}" 
                    placeholder="Ïù∏ÎèÑÎÑ§ÏãúÏïÑÏñ¥ Îã®Ïñ¥">
                <input type="text" class="edit-input" value="${word.meaning}" 
                    oninput="updateWordTemp(${id}, this.value, 'meaning')" 
                    onkeydown="if(event.key==='Enter'){saveEdit(${id}); event.preventDefault();}" 
                    placeholder="ÌïúÍµ≠Ïñ¥ Îúª">
                <div class="word-actions">
                    <button class="btn btn-small" onclick="saveEdit(${id}); event.stopPropagation();">Ï†ÄÏû•</button>
                    <button class="btn btn-secondary btn-small" onclick="cancelEdit(${id}); event.stopPropagation();">Ï∑®ÏÜå</button>
                    <button class="btn btn-small btn-kbbi" onclick="showKBBI(${id}); event.stopPropagation();">KBBI</button>
                    <button class="btn btn-small btn-daum" onclick="showDaum(${id}); event.stopPropagation();">Daum</button>
                </div>`;
            wordItem.querySelector('.edit-input')?.focus();
        }, 0);
    }

    function updateWordTemp(id, value, field) {
        const word = vocabulary.words.find(w => w.id === id);
        if (word) {
            if (field === 'word') word.word = value.trim().toLowerCase();
            else word.meaning = value.trim();
        }
    }

    function saveEdit(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (!word || !word.word || !word.meaning) {
            alert('Îã®Ïñ¥ÏôÄ ÎúªÏùÑ Î™®Îëê ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }
        if (vocabulary.words.some(w => w.id !== id && w.word === word.word)) {
            alert('Ïù¥ÎØ∏ ÎèôÏùºÌïú Îã®Ïñ¥Í∞Ä Ï°¥Ïû¨Ìï©ÎãàÎã§.');
            return;
        }
        delete word.originalWord;
        delete word.originalMeaning;
        renderWordItem(id);
        updateStats();
        saveToStorage();
    }

    function cancelEdit(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (word && word.originalWord && word.originalMeaning) {
            word.word = word.originalWord;
            word.meaning = word.originalMeaning;
            delete word.originalWord;
            delete word.originalMeaning;
        }
        renderWordItem(id);
        updateStats();
    }

    function renderWordItem(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (!word) return;
        const wordItem = document.querySelector(`[data-word-id="${id}"]`);
        if (wordItem) {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            if (!searchTerm || word.word.includes(searchTerm) || word.meaning.includes(searchTerm)) {
                wordItem.classList.remove('edit-mode');
                wordItem.innerHTML = `
                    <div class="word-text">${word.word}</div>
                    <div class="word-meaning">${word.meaning}</div>
                    <div class="word-actions">
                        <button class="btn btn-small" onclick="event.stopPropagation(); toggleMemorized(${word.id})">
                            ${word.memorized ? 'ÏïîÍ∏∞ Ï∑®ÏÜå' : 'ÏïîÍ∏∞ ÏôÑÎ£å'}
                        </button>
                        <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); deleteWord(${word.id})">ÏÇ≠Ï†ú</button>
                        <button class="btn btn-small btn-edit" onclick="event.stopPropagation(); enterEditMode(${word.id})" title="ÏàòÏ†ï">‚úèÔ∏è ÏàòÏ†ï</button>
                        <button class="btn btn-small btn-kbbi" onclick="event.stopPropagation(); showKBBI(${word.id})">KBBI</button>
                        <button class="btn btn-small btn-daum" onclick="event.stopPropagation(); showDaum(${word.id})">Daum</button>
                    </div>`;
                wordItem.onclick = () => { if (!event.target.closest('.word-actions')) enterEditMode(id); };
            } else {
                wordItem.remove();
            }
        }
    }

    function updateStats() {
        document.getElementById('totalWords').textContent = vocabulary.words.length;
        const memorizedCount = vocabulary.words.filter(w => w.memorized).length;
        document.getElementById('memorizedWords').textContent = memorizedCount;
        document.getElementById('remainingWords').textContent = vocabulary.words.length - memorizedCount;
    }

    function updateDisplay(searchTerm = '') {
        const filteredWords = vocabulary.words.filter(word => 
            word.word.includes(searchTerm) || word.meaning.includes(searchTerm)
        );
        const notMemorized = filteredWords.filter(w => !w.memorized);
        const memorized = filteredWords.filter(w => w.memorized);

        shuffleArray(notMemorized);
        shuffleArray(memorized);

        updateStats();

        const renderList = (container, data, paginatedData) => {
            container.innerHTML = data.length === 0 
                ? '<div class="empty-state">Ìï¥Îãπ Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.</div>'
                : paginatedData.map(word => `
                    <div class="word-item" data-word-id="${word.id}" 
                        onclick="if (!event.target.closest('.word-actions')) enterEditMode(${word.id})">
                        <div class="word-text">${word.word}</div>
                        <div class="word-meaning">${word.meaning}</div>
                        <div class="word-actions">
                            <button class="btn btn-small" onclick="event.stopPropagation(); toggleMemorized(${word.id})">
                                ${word.memorized ? 'ÏïîÍ∏∞ Ï∑®ÏÜå' : 'ÏïîÍ∏∞ ÏôÑÎ£å'}
                            </button>
                            <button class="btn btn-secondary btn-small" onclick="event.stopPropagation(); deleteWord(${word.id})">ÏÇ≠Ï†ú</button>
                            <button class="btn btn-small btn-edit" onclick="event.stopPropagation(); enterEditMode(${word.id})" title="ÏàòÏ†ï">‚úèÔ∏è ÏàòÏ†ï</button>
                            <button class="btn btn-small btn-kbbi" onclick="event.stopPropagation(); showKBBI(${word.id})">KBBI</button>
                            <button class="btn btn-small btn-daum" onclick="event.stopPropagation(); showDaum(${word.id})">Daum</button>
                        </div>
                    </div>`).join('');
        };

        const notMemorizedList = document.getElementById('notMemorizedList');
        const paginatedNotMem = notMemorized.slice(
            (currentPageNotMem - 1) * ITEMS_PER_PAGE,
            currentPageNotMem * ITEMS_PER_PAGE
        );
        renderList(notMemorizedList, notMemorized, paginatedNotMem);
        renderPagination('notMemPagination', notMemorized.length, currentPageNotMem, 'notMem');

        const memorizedList = document.getElementById('memorizedList');
        const paginatedMem = memorized.slice(
            (currentPageMem - 1) * ITEMS_PER_PAGE,
            currentPageMem * ITEMS_PER_PAGE
        );
        renderList(memorizedList, memorized, paginatedMem);
        renderPagination('memPagination', memorized.length, currentPageMem, 'mem');
    }

    function showKBBI(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (word) window.open(
            `https://kbbi.web.id/${encodeURIComponent(word.word)}`,
            'kbbiSearch',
            'width=1200,height=600,scrollbars=yes,resizable=yes'
        );
    }

    function showDaum(id) {
        const word = vocabulary.words.find(w => w.id === id);
        if (word) window.open(
            `https://dic.daum.net/search.do?q=${encodeURIComponent(word.word)}&dic=id`,
            'daumSearch',
            'width=1200,height=600,scrollbars=yes,resizable=yes'
        );
    }

    // --- Flashcard Functions ---
    const flashcardModal = document.getElementById('flashcard-modal');

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function startFlashcardSession(mode) {
        currentFlashcardMode = mode;
        if (mode === 'notMemorized') {
            flashcardWords = vocabulary.words.filter(w => !w.memorized);
        } else {
            flashcardWords = vocabulary.words.filter(w => w.memorized);
        }
        
        if (flashcardWords.length === 0) {
            const alertMessage = mode === 'notMemorized'
                ? 'ÌîåÎûòÏãúÏπ¥ÎìúÎ°ú ÌïôÏäµÌï† Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.'
                : 'Î≥µÏäµÌï† ÏïîÍ∏∞Ìïú Îã®Ïñ¥Í∞Ä ÏóÜÏäµÎãàÎã§.';
            alert(alertMessage);
            return;
        }
        
        shuffleArray(flashcardWords);
        currentFlashcardIndex = 0;
        flashcardModal.style.display = 'block';
        displayFlashcard();
    }

    function displayFlashcard() {
        if (flashcardWords.length === 0) {
            closeFlashcardModal();
            return;
        }
        const word = flashcardWords[currentFlashcardIndex];
        document.getElementById('flashcard-progress').textContent =
            `${currentFlashcardIndex + 1} / ${flashcardWords.length}`;
        document.getElementById('flashcard-front').textContent = word.word;
        document.getElementById('flashcard-back').textContent = word.meaning;
        document.getElementById('flashcard').classList.remove('is-flipped');

        const actionBtn = document.getElementById('flashcard-action-btn');
        if (currentFlashcardMode === 'notMemorized') {
            actionBtn.textContent = 'ÏïîÍ∏∞ ÏôÑÎ£å';
            actionBtn.className = 'btn btn-secondary';
        } else {
            actionBtn.textContent = 'Îã§Ïãú ÏïîÍ∏∞ÌïòÍ∏∞';
            actionBtn.className = 'btn btn-review';
        }
    }

    function showNextFlashcard() {
        if (flashcardWords.length === 0) return;
        currentFlashcardIndex = (currentFlashcardIndex + 1) % flashcardWords.length;
        displayFlashcard();
    }

    function showPrevFlashcard() {
        if (flashcardWords.length === 0) return;
        currentFlashcardIndex =
            (currentFlashcardIndex - 1 + flashcardWords.length) % flashcardWords.length;
        displayFlashcard();
    }

    function handleFlashcardAction() {
        if (flashcardWords.length === 0) return;
        const currentWord = flashcardWords[currentFlashcardIndex];
        const originalWord = vocabulary.words.find(w => w.id === currentWord.id);
        
        if (originalWord) {
            originalWord.memorized = !originalWord.memorized;
        }

        flashcardWords.splice(currentFlashcardIndex, 1);
        
        if (currentFlashcardIndex >= flashcardWords.length && flashcardWords.length > 0) {
            currentFlashcardIndex = 0;
        }
        
        displayFlashcard();
    }

    function closeFlashcardModal() {
        flashcardModal.style.display = 'none';
        saveToStorage();
        updateDisplay();
    }
    
    document.getElementById('startNotMemFlashcardBtn')
        .addEventListener('click', () => startFlashcardSession('notMemorized'));
    document.getElementById('startMemFlashcardBtn')
        .addEventListener('click', () => startFlashcardSession('memorized'));

    flashcardModal.querySelector('.close-button')
        .addEventListener('click', closeFlashcardModal);
    document.getElementById('flashcard')
        .addEventListener('click', () =>
            document.getElementById('flashcard').classList.toggle('is-flipped')
        );
    document.getElementById('flashcard-next-btn')
        .addEventListener('click', showNextFlashcard);
    document.getElementById('flashcard-prev-btn')
        .addEventListener('click', showPrevFlashcard);
    document.getElementById('flashcard-action-btn')
        .addEventListener('click', handleFlashcardAction);

    document.getElementById('wordInput').addEventListener('keypress', e => {
        if (e.key === 'Enter') document.getElementById('meaningInput').focus();
    });
    document.getElementById('meaningInput').addEventListener('keypress', e => {
        if (e.key === 'Enter') addWord();
    });

    updateDisplay();
</script>


</body>
</html>
